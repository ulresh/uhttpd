# 4. Разбор запроса

### lesson04.1

Начнём чтение запроса. Ограничим время получения и размер входящего запроса.

В конфигурацию добавим параметры `request_timeout`, `max_request_header_size`, `max_request_body_size`. Сразу зададим для них значения по умолчанию.
Файл [src/uhttpd/config.hpp](/../lesson04.1/src/uhttpd/config.hpp), [посмотреть отличия](/../../compare/c041..c041a).

В файле [src/stdlibs.hpp](/../lesson04.1/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c041a..c041b) добавим `list` и `boost::asio::deadline_timer`. Также в этот файл кроме стандартных библиотек вынесем предварительные объявляения наших классов.

В файле [src/acceptor.hpp](/../lesson04.1/src/acceptor.hpp), [посмотреть отличия](/../../compare/c041b..c041c) поправим вывод `this`, там получилось слишком много двоеточий.

В файле [src/acceptor.cpp](/../lesson04.1/src/acceptor.cpp), [посмотреть отличия](/../../compare/c041c..c041d) заменим вызов `async_read` на `async_start` и добавим в сообщение адрес объекта `IncomingConnection`.

Добавим в класс `Server` поле `incomings` со списком всех активных входящих соединений.
Файл [src/server.hpp](/../lesson04.1/src/server.hpp), [посмотреть отличия](/../../compare/c041d..c041e).

В функции `Server::close` закроем активные входящие соединения.
Файл [src/server.cpp](/../lesson04.1/src/server.cpp), [посмотреть отличия](/../../compare/c041e..c041f).

В классе IncomingConnection. Добавляем функцию `close`. Переименовываем функцию `async_read` в `async_start` (чисто логически название async_read предполагает возможность нескольких вызовов за цикл работы, а async_start обозначает начало рабочего цикла). Добавляем функции `async_read_header` и `handle_read_header`. Добавляем константу `header_buffer_size`. Добавляем поле `anchor` для быстрого удаления объекта из общего списка. Добавляем поля `timer` и `buffer`. Поля `state` и `up_state` пока не используем, они потребуются на следующих шагах для разбора. Добавляем поле `header_size` для ограничения размера запроса. Это ограничение нужно для защиты от того, что входящий запрос займёт памяти больше, чем имеется в системе.
Добавляем вывод this.
Файл [src/incoming-connection.hpp](/../lesson04.1/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c041f..c041g).

Файл [src/incoming-connection.cpp](/../lesson04.1/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c041g..c041h).

В функции `IncomingConnection::close` защищаемся от двойного вызова (как минимум значение `anchor` после первого вызова становится невалидным). Удаляемся из общего списка. Останавливаем таймер. Закрываем сокет.

В функции `IncomingConnection::async_start` добавляемся в общий список, сохраняем в `anchor` позицию в этом списке для удаления. Заводим таймер получения запроса. Если таймер сработает раньше того, как мы прочитаем весь запрос, закрываем соединение. Такой таймер нужен для освобождения памяти от запросов, зависших из-за сетевых проблем (на практике реальна ситуация, что клиента давно нет, но соединение остаётся висеть, по тем или иным причинам не получив команду на закрытие). Выделяем память под буфер для чтения. Вызываем чтение заголовка запроса.

В функции `IncomingConnection::async_read_header` только вызов `socket.async_read_some`. Там достаточно большой список параметров, поэтому этот вызов заслужил отдельную функцию.

В функции `IncomingConnection::handle_read_header` на этом шаге пока только скелет. Мы будем её ещё достаточно долго дорабатывать. На данный момент здесь есть проверка флагов `closing`, проверка ошибки, проверка ограничения размера заголовка, вызов чтения следующей порции заголовка. Вызов следующего чтения нужен даже не из-за того, что такой большой запрос. Просто запрос может нам прийти несколькими порциями меньшего размера. Мы всё же используем `socket.async_read_some`, который вызывает обработку на каждый полученный кусок, не накапливая их в буфере.




### lesson04.2

Обычно во всех примерах для разбора запроса используют многопроходный подход. То есть сперва ищут конец строки, потом первую строку разбивают на method, url, protocol. Далее url делят на path, query_string, anchor. Далее в свою очередь разбирают path и query_string. Преимущество такого подхода - его понятность. То есть в коде сразу видно где что и для чего.

Мне в многопроходном подходе не нравится необходимость выделять память под промежуточные значения и расход времени на несколько проходов.

Весь разбор можно сделать одним проходом. Мне нравится использовать для этого конечный автомат. То есть определяем набор состояний, между которыми переходим в зависимости от следующего символа. Часто для построения конечных автоматов используют утилиты lex и yacc (это древность, современные flex, bison и т.д.). Но эти утилиты имеют достаточно узкую специализацию. Мне проще написать автомат прямо кодом.

Конечный автомат для разбора запроса будет работать в функции `IncomingConnection::handle_read_header`.

В классе `IncomingConnection` добавим поля `method` и `path` для хранения разобранных значений. Поле `path` делаем в виде списка, разобранного по символу `/`. Первый элемент списка - пустой (`path` начинается с `/`). Состояние автомата записываем в добавленное ранее поле `state`. Поля `http_version`, `proto` и `keep_alive` добавлены для следующих шагов (пока не используем).

Добавим функцию `clear_state` для инициализации полей перед разбором и очистки значений от предыдущего запроса для случая нескольких запросов в одном соединении.

В функции `async_read_header` и `handle_read_header` добавляем параметры `offset` и `mark_offset`. В ряде случаев нам будет удобнее (эффективнее) не освобождать весь буфер для нового чтения, а оставив часть занятой, провести чтение в свободную часть. `offset` задаёт начало свободной части буфера. `mark_offset` задаёт начало текущего значения в занятой части буфера. `mark_offset` < `offset` или `mark_offset` == `offset` == 0.

Переместим начльные значения полей из общего заголовка класса в функцию `clear_state`.

Файл [src/incoming-connection.hpp](/../lesson04.2/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c042..c042a).

В функции `IncomingConnection::async_start` заменим инициализацию полей `state` и `header_size` на вызов `clear_state()`.

В функции `IncomingConnection::async_read_header` добавим обработку параметров `offset` и `mark_offset`.

В функции `IncomingConnection::handle_read_header` начинаем построение автомата. Перед функцией размещаем комментарий, в котором очень схематично обозначаем значение состояний.

Добавим локальные переменные - указатели на позицию в буфере. `mark` - начало текущей строки, которую мы плнируем скопировать в значение без дополнительной обработки. `ptr` - указатель на текущий символ. `end` - первый символ после заполненной части буфера. `end1` - последний символ заполненной части буфера.

Обычно автомат работает так, что по таблице состояние/символ мы определяем новое состояние и необходимое действие по обработке данных. Я не ставлю себе задачу сделать классический конечный автомат, поэтому позволяю себе ряд особенностей, когда считаю что так будет быстрее/удобней. Я не делаю проверку состояния на каждый символ там где без этого можно обойтись. При переходе на следующее состояние я не выхожу из `switch` там, где такое возможно.

Файл [src/incoming-connection.cpp](/../lesson04.2/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c042a..c042b).




### lesson04.3

### TODO
* ssl
* threads
* multieol in logs before exit
* Logger::File::ready if(error) переделать
* segv backtrace addr2line
* LOGT("request_timeout")

### REMARKS

Второй запрос, пришедший до отправки ответа на первый, считаем ошибкой и закрываем соединение.

Добавить промежуточный уровень сообщений между _DEBUG и production.
