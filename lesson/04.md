# 4. Разбор запроса

### lesson04.1

Начнём чтение запроса. Ограничим время получения и размер входящего запроса.

В конфигурацию добавим параметры `request_timeout`, `max_request_header_size`, `max_request_body_size`. Сразу зададим для них значения по умолчанию.
Файл [src/uhttpd/config.hpp](/../lesson04.1/src/uhttpd/config.hpp), [посмотреть отличия](/../../compare/c041..c041a).

В файле [src/stdlibs.hpp](/../lesson04.1/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c041a..c041b) добавим `list` и `boost::asio::deadline_timer`. Также в этот файл кроме стандартных библиотек вынесем предварительные объявляения наших классов.

В файле [src/acceptor.hpp](/../lesson04.1/src/acceptor.hpp), [посмотреть отличия](/../../compare/c041b..c041c) поправим вывод `this`, там получилось слишком много двоеточий.

В файле [src/acceptor.cpp](/../lesson04.1/src/acceptor.cpp), [посмотреть отличия](/../../compare/c041c..c041d) заменим вызов `async_read` на `async_start` и добавим в сообщение адрес объекта `IncomingConnection`.

Добавим в класс `Server` поле `incomings` со списком всех активных входящих соединений.
Файл [src/server.hpp](/../lesson04.1/src/server.hpp), [посмотреть отличия](/../../compare/c041d..c041e).

В функции `Server::close` закроем активные входящие соединения.
Файл [src/server.cpp](/../lesson04.1/src/server.cpp), [посмотреть отличия](/../../compare/c041e..c041f).

В классе IncomingConnection. Добавляем функцию `close`. Переименовываем функцию `async_read` в `async_start` (чисто логически название async_read предполагает возможность нескольких вызовов за цикл работы, а async_start обозначает начало рабочего цикла). Добавляем функции `async_read_header` и `handle_read_header`. Добавляем константу `header_buffer_size`. Добавляем поле `anchor` для быстрого удаления объекта из общего списка. Добавляем поля `timer` и `buffer`. Поля `state` и `up_state` пока не используем, они потребуются на следующих шагах для разбора. Добавляем поле `header_size` для ограничения размера запроса. Это ограничение нужно для защиты от того, что входящий запрос займёт памяти больше, чем имеется в системе.
Добавляем вывод this.
Файл [src/incoming-connection.hpp](/../lesson04.1/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c041f..c041g).

Файл [src/incoming-connection.cpp](/../lesson04.1/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c041g..c041h).

В функции `IncomingConnection::close` защищаемся от двойного вызова (как минимум значение `anchor` после первого вызова становится невалидным). Удаляемся из общего списка. Останавливаем таймер. Закрываем сокет.

В функции `IncomingConnection::async_start` добавляемся в общий список, сохраняем в `anchor` позицию в этом списке для удаления. Заводим таймер получения запроса. Если таймер сработает раньше того, как мы прочитаем весь запрос, закрываем соединение. Такой таймер нужен для освобождения памяти от запросов, зависших из-за сетевых проблем (на практике реальна ситуация, что клиента давно нет, но соединение остаётся висеть, по тем или иным причинам не получив команду на закрытие). Выделяем память под буфер для чтения. Вызываем чтение заголовка запроса.

В функции `IncomingConnection::async_read_header` только вызов `socket.async_read_some`. Там достаточно большой список параметров, поэтому этот вызов заслужил отдельную функцию.

В функции `IncomingConnection::handle_read_header` на этом шаге пока только скелет. Мы будем её ещё достаточно долго дорабатывать. На данный момент здесь есть проверка флагов `closing`, проверка ошибки, проверка ограничения размера заголовка, вызов чтения следующей порции заголовка. Вызов следующего чтения нужен даже не из-за того, что такой большой запрос. Просто запрос может нам прийти несколькими порциями меньшего размера. Мы всё же используем `socket.async_read_some`, который вызывает обработку на каждый полученный кусок, не накапливая их в буфере.




### lesson04.2

Обычно во всех примерах для разбора запроса используют многопроходный подход. То есть сперва ищут конец строки, потом первую строку разбивают на method, url, protocol. Далее url делят на path, query_string, anchor. Далее в свою очередь разбирают path и query_string. Преимущество такого подхода - его понятность. То есть в коде сразу видно где что и для чего.

Мне в многопроходном подходе не нравится необходимость выделять память под промежуточные значения и расход времени на несколько проходов.

Весь разбор можно сделать одним проходом. Мне нравится использовать для этого конечный автомат. То есть определяем набор состояний, между которыми переходим в зависимости от следующего символа. Часто для построения конечных автоматов используют утилиты lex и yacc (это древность, современные flex, bison и т.д.). Но эти утилиты имеют достаточно узкую специализацию. Мне проще написать автомат прямо кодом.

Конечный автомат для разбора запроса будет работать в функции `IncomingConnection::handle_read_header`.

В классе `IncomingConnection` добавим поля `method` и `path` для хранения разобранных значений. Поле `path` делаем в виде списка, разобранного по символу `/`. Первый элемент списка - пустой (`path` начинается с `/`). Состояние автомата записываем в добавленное ранее поле `state`. Поля `http_version`, `proto` и `keep_alive` добавлены для следующих шагов (пока не используем).

Добавим функцию `clear_state` для инициализации полей перед разбором и очистки значений от предыдущего запроса для случая нескольких запросов в одном соединении.

В функции `async_read_header` и `handle_read_header` добавляем параметры `offset` и `mark_offset`. В ряде случаев нам будет удобнее (эффективнее) не освобождать весь буфер для нового чтения, а оставив часть занятой, провести чтение в свободную часть. `offset` задаёт начало свободной части буфера. `mark_offset` задаёт начало текущего значения в занятой части буфера. `mark_offset` < `offset` или `mark_offset` == `offset` == 0.

Переместим начальные значения полей из общего заголовка класса в функцию `clear_state`.

Файл [src/incoming-connection.hpp](/../lesson04.2/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c042..c042a).

В функции `IncomingConnection::async_start` заменим инициализацию полей `state` и `header_size` на вызов `clear_state()`.

В функции `IncomingConnection::async_read_header` добавим обработку параметров `offset` и `mark_offset`.

В функции `IncomingConnection::handle_read_header` начинаем построение автомата. Перед функцией размещаем комментарий, в котором очень схематично обозначаем значение состояний.

Добавим локальные переменные - указатели на позицию в буфере. `mark` - начало текущей строки, которую мы плнируем скопировать в значение без дополнительной обработки. `ptr` - указатель на текущий символ. `end` - первый символ после заполненной части буфера. `end1` - последний символ заполненной части буфера.

Обычно автомат работает так, что по таблице состояние/символ мы определяем новое состояние и необходимое действие по обработке данных. Я не ставлю себе задачу сделать классический конечный автомат, поэтому позволяю себе ряд особенностей, когда считаю что так будет быстрее/удобней. Я не делаю проверку состояния на каждый символ там где без этого можно обойтись. При переходе на следующее состояние я не выхожу из `switch` там, где такое возможно.

Первый цикл `for(; ptr < end; ++ptr)` на данном шаге не используется. От понадобится нам позже. Добавлен сейчас, чтобы потом не менять отступ у большого куска кода.

Сразу добавляем обработку ситуации с неизвестным `state` (`switch default`).
Так то у нас такой ситуации не будет. Но никогда нельзя исключать ситуацию с испорченной памятью (по самым разным причинам). И лучше всё же предусмотреть какое-то действие при обнаружении неожиданного значения в `state`.

На этом шаге мы сделали обработку состояний 0-2 полностью и начали обработку состояния 3.

Файл [src/incoming-connection.cpp](/../lesson04.2/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c042a..c042b).




### lesson04.3.1

На предыдущем шаге была ошибка в `IncomingConnection::handle_read_header` state=3, *ptr default. Там при добавлении куска строки в `path` был указан `ptr`, в результате чего последний символ из буфера не будет добавлен. А нам он нужен. Так что вместо `ptr` должен быть использован `end`.
Файл [src/incoming-connection.cpp](/../lesson04.3.1/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c043..c043a).

У меня написание учебника отстаёт от написания кода.
При этом разбивка на шаги идёт конечно же сразу как пишется код.
Но вот сейчас при описании шага пришло понимание, что шаг получился слишком
громоздким. Я его разбил, а чтобы не переименовывать следующие шаги
появилась третья цифра в имени шага.




### lesson04.3.2

В диагностических сообщениях очень часто приводится символ, который стал причиной ошибки разбора. Очень часто это может быть тот или иной спецсимвол, так что нужно в сообщение выводить его код. Чтобы не писать много в каждом сообщении, создадим класс `LogChar`, единственная задача которого - переопледение оператора `<<`. Сам символ выводить будем только в том случае, если он отображаемый и не пробел. Код символа выводим всегда. Файл [src/logger.hpp](/../lesson04.3.2/src/logger.hpp), [посмотреть отличия](/../../compare/c043a..c043b).

Добавим везде, где ранее в журнал выводился текущий символ, новый класс.
Файл [src/incoming-connection.cpp](/../lesson04.3.2/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c043b..c043c).




### lesson04.3.3

Создадим новую функцию `IncomingConnection::parsed_string_append`. Задачей этой функции будет сократить количество вызовов `std::string::append` для оптимизации работы памяти. Функцию будем вызывать в тех случаях, когда мы при разборе достигли конца полученного блока, это означает, что текущее значение распознано не полностью и в следующем чтении значение будет продолжено. Совсем хорошо, когда в нашем буфере есть ещё место для нового чтения.
Дрогой случей, если распознанная часть небольшая, то её можно сдвинуть в начало буфера. Но если в строке со значением уже выделен достаточный объём памяти, то копировать лучше всё таки сразу туда.
Не забываем перед вызовом этой функции (то есть вызовом нового чтения внутри
её) проконтролировать превышение размера заголовка.
Для этого данный контроль из конца функции
`IncomingConnection::handle_read_header` переместим в макрос
`CHECK_HEADER_SIZE`, который теперь будем использовать в том числе и перед
всеми вызовами новой функции.
После вызова функции `parsed_string_append` также выходим и из функции
`handle_read_header`.
Заменим в `state 3 default` вызов `std::string::append` на
`parsed_string_append`.
Было желание объединить макрос проверки размера, вызов новой функции и
`return` в новый макрос, но не стал этого делать из того соображения,
что в данном случае мне важнее видеть в коде явный `return`, чем немного
сократить код. Да и проверку совсем не лишнее видеть явно.

Файл [src/incoming-connection.hpp](/../lesson04.3.3/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c043c..c043d).
Файл [src/incoming-connection.cpp](/../lesson04.3.3/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c043d..c043e).




### lesson04.3.4

Добавляем разбор кода символа, заданного конструкцией `%XX` в состоянии 3.
Сохраним просмотренный кусок текста в `path.back()`.
Поскольку код символа может встречаться не только в `path`,
сохраним текущее состояние в поле `up_state`.
Изменим состояние на 4. Проверим достижение конца полученного куска.
По результатам проверки либо отправляем команду на новое чтение и завершаем
функцию, либо сдвигаемся на следующий символ и переходим на состояние 4.

Лля сокращения записи действий в случае неправильной конструкции определим макрос BAD, действующий только для состояний 4 и 5.

Проверку шестнадцатеричного числа сделаем конструкцией `if-else-if`,
в которой условия отсортированы по возрастанию кода, что даёт нам
возможность проверять только на меньше.

Полученный код символа временно сохраняем в новом поле 'decoded_char'.

Из состояния 4 переходим в состояние 5 без возврата к основному 'switch(state)'. Только проверяем на конец разбираемого куска.

После разбора символа в состоянии 5 меняем состояние на значение из
`up_state`. В зависимости от этого состояния помещаем значение 'decoded_char'
в нужное поле. Для `up_state=3` это `path.back()`.

После проверки конца куска переходим на основной 'switch(state)'.

Файл [src/incoming-connection.hpp](/../lesson04.3.4/src/incoming-connection.hpp), [посмотреть отличия](/../../compare/c043e..c043f).
Файл [src/incoming-connection.cpp](/../lesson04.3.4/src/incoming-connection.cpp), [посмотреть отличия](/../../compare/c043f..c043g).




### lesson04.4

### TODO
* ssl
* threads
* multieol in logs before exit
* Logger::File::ready if(error) переделать
* segv backtrace addr2line
* LOGT("request_timeout")

### REMARKS

Второй запрос, пришедший до отправки ответа на первый, считаем ошибкой и закрываем соединение.

Добавить промежуточный уровень сообщений между _DEBUG и production.
