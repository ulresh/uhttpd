# 1. Скелет сервера.

В тексте учебника я не буду приводить куски кода, только имена файлов с кодом. Ну а поскольку по мере занятий файлы кода будут меняться, то для просмотра кода из определенного занятия следует использовать теги git'а. Теги будут состоять из двух цифр - номер занятия и номер итерации кода в пределах занятия.

При этом текст учебника скорее всего будет удобнее смотреть на сайте, не забывая при этом переключаться на ветку master. Дело в том, что при переключении на тег, большая часть учебника будет теряться, поскольку учебник пишется параллельно созданию тегов. А все ссылки из текста на файлы привязаны к текущему тегу. При этом в тексте учебника, привязанного к тегу, информация может быть не только неполной, но и устаревшей, поскольку при написании новых разделов я допускаю исправление предыдущих разделов. Так что текст читаем только в ветке master.

При просмотре через сайт github для возврата от кода к тексту можно использовать файл current-lesson.md в корне проекта. Там ссылка содержит переход к ветке master.

### lesson01.1

В первую очередь, при начале любого проекта, предполагающего компиляцию, создаём файл [.gitignore](https://github.com/ulresh/umake/blob/lesson01.1/.gitignore), в котором укажем папки для файлов с результатами компиляции.

Из проекта [umake](/../../../umake) возьмём основы файлов [src/stdlibs.hpp](/../lesson01.1/src/stdlibs.hpp), [src/build.umake](/../lesson01.1/src/build.umake), [note/custom/reshu-lenovo/build.local.umake](/../lesson01.1/note/custom/reshu-lenovo/build.local.umake). Создадим симлинк `src/build.local.umake`.
```
cd src
ln -s ../note/custom/reshu-lenovo/build.local.umake
```

Далее создаём файл [src/main.cpp](/../lesson01.1/src/main.cpp) с точкой входа для нашей программы.

Собираем программу при помощи утилиты [umake](/../../../umake).
```
cd src; ../../umake/bin/umake; cd ..
```


### lesson01.2

Работу начинаем с конфигурационного файла. Чтобы не терять время на написание разбора и при этом не ограничивать будущий функционал, сделаем конфигурационный файл на языке Си++.

В файле [src/uhttpd/config.hpp](/../lesson01.2/src/uhttpd/config.hpp) разместим заголовок класса Config.

Из проекта [umake](/../../../umake) возьмём файл [src/umake/custom.hpp](/../lesson01.2/src/umake/custom.hpp).

Создадим файл [conf/uhttpd.config](/../lesson01.2/conf/uhttpd.config) с тестовой конфигурацией.

Для флагов сборки конфигурационного файла создадим файл [conf/build.umake](/../lesson01.2/conf/build.umake).

Создадим скелет класса Server в файлах
[src/server.hpp](/../lesson01.2/src/server.hpp) и
[src/server.cpp](/../lesson01.2/src/server.cpp).

В файле [src/main.cpp](/../lesson01.2/src/main.cpp), [посмотреть отличия](/../../compare/c012..c012a) добавим обработку параметра с именем конфигурационного файла и вызов класса Server.

В файле [src/stdlibs.hpp](/../lesson01.2/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c012a..c012b) поменяем io_service на io_context. Честно говоря, не представляю чем они отличаются, но поскольку в текущей документации на [boost::asio](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio.html) упомянут только io_context, то будем использовать его.


### lesson01.3

Добавляем компиляцию и загрузку конфигурационного файла. За основу взят код загрузки настраиваемых данных из проекта [umake](/../../../umake).

В файле [src/server.hpp](/../lesson01.3/src/server.hpp), [посмотреть отличия](/../../compare/c013..c013a) добавим поля cc (путь к компилятору) и umake_custom (настраиваемые данные для компиляции конфигурационного файла).

В файле [src/umake/custom.hpp](/../lesson01.3/src/umake/custom.hpp), [посмотреть отличия](/../../compare/c013a..c013b) добавим namespace umake.

В файле [conf/build.umake](/../lesson01.3/conf/build.umake), [посмотреть отличия](/../../compare/c013b..c013c) добавим namespace umake и путь `src` к файлу `src/uhttpd/config.hpp`.

В файле [src/uhttpd/config.hpp](/../lesson01.3/src/uhttpd/config.hpp), [посмотреть отличия](/../../compare/c013c..c013d) добавим короткое имя для `boost::asio::ip`.

В файле [conf/uhttpd.config](/../lesson01.3/conf/uhttpd.config), [посмотреть отличия](/../../compare/c013d..c013e) добавим пропущенную букву в пути файла `uhttpd/config.hpp`.

В файле [src/server.cpp](/../lesson01.3/src/server.cpp), [посмотреть отличия](/../../compare/c013e..c013f) добавим тело функции Server::load_config (собственно именно здесь весь функционал, добавляемый на данном шаге).

В файле [.gitignore](/../lesson01.3/.gitignore), [посмотреть отличия](/../../compare/c013f..c013g) добавим пропуск откомпилированных конфигов `/conf/*.so`.


### lesson01.4

Добавим ожидание входящих соединений. Для этого нам потребуются [boost::asio::ip::tcp::acceptor](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio/reference/ip__tcp/acceptor.html) и [boost::asio::ip::tcp::socket](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio/reference/ip__tcp/socket.html).

Добавим в файле [src/stdlibs.hpp](/../lesson01.4/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c014..c014a) сокращения для boost::asio::ip и boost::asio::ip::tcp.

Создадим скелет класса IncomingConnection в файлах
[src/incoming-connection.hpp](/../lesson01.4/src/incoming-connection.hpp) и
[src/incoming-connection.cpp](/../lesson01.4/src/incoming-connection.cpp).

Создадим класс Acceptor в файлах
[src/acceptor.hpp](/../lesson01.4/src/acceptor.hpp) и
[src/acceptor.cpp](/../lesson01.4/src/acceptor.cpp).
Сразу добавим здесь обработку входящего соединения async_accept/handle_accept.

В файле [src/server.hpp](/../lesson01.4/src/server.hpp), [посмотреть отличия](/../../compare/c014a..c014b) в классе Server добавим поля acceptor и closing.

На поле closing остановлюсь чуть подробнее. Это поле, кроме класса Server, будет у нас во всех классах с асинхронными операциями. И мы возьмём за правило в каждом обработчике для асинхронных операций в первую очередь проверять closing (свой и сервера). Это связано с тем, что при асинхронных операциях процесс удаления объекта получается растянутым во времни, до завершения всех инициированных операций. Нам важно определить объект как закрываемый и не допустить в нём запуска новых обработчиков.

Также чуть подробнее расскажу про передачу shared_ptr во все обработчики асинхронных операций. Это сделано для того, чтобы избежать ситуаций, когда память из под объекта освобождена раньше выполнения обработчика. На первый взгляд такой подход лишний, вроде бы достаточно поместить объект в общий список, чтобы он не был освобождён раньше времени. Но рано или поздно нам потребуется объект из списка удалить, и у нас всё равно встанет задача отследить, чтобы все обработчики с этим объектом были завершены. Так что проще сразу добавить в обработчик shared_ptr на используемый объект.

В файле [src/server.cpp](/../lesson01.4/src/server.cpp), [посмотреть отличия](/../../compare/c014b..c014c) в функции `Server::async_start` добавим создание acceptor'а и вызов у него функции `async_accept`.

На этом шаге уже можно наш сервер запустить и даже получить от него какой-то отклик, пусть и всего лишь "сервер разорвал Ваше соединение". Обратите внимание, что две команды следует запускать в разных консолях (одна команла в консоли). Выполнение сервера завершаем комбинацией клавиш Contol-C.

```
bin/uhttpd conf/uhttpd.config
curl -v http://127.0.0.1:8080/
```


### lesson01.5



### TODO
* buffer
* read timer
* sigterm
* ssl
* threads
