# 1. Скелет сервера.

В тексте учебника я не буду приводить куски кода, только имена файлов с кодом. Ну а поскольку по мере занятий файлы кода будут меняться, то для просмотра кода из определенного занятия следует использовать теги git'а. Теги будут состоять из двух цифр - номер занятия и номер итерации кода в пределах занятия.

При этом текст учебника скорее всего будет удобнее смотреть на сайте, не забывая при этом переключаться на ветку master. Дело в том, что при переключении на тег, большая часть учебника будет теряться, поскольку учебник пишется параллельно созданию тегов. А все ссылки из текста на файлы привязаны к текущему тегу. При этом в тексте учебника, привязанного к тегу, информация может быть не только неполной, но и устаревшей, поскольку при написании новых разделов я допускаю исправление предыдущих разделов. Так что текст читаем только в ветке master.

При просмотре через сайт github для возврата от кода к тексту можно использовать файл current-lesson.md в корне проекта. Там ссылка содержит переход к ветке master.

### lesson01.1

В первую очередь, при начале любого проекта, предполагающего компиляцию, создаём файл [.gitignore](https://github.com/ulresh/umake/blob/lesson01.1/.gitignore), в котором укажем папки для файлов с результатами компиляции.

Из проекта [umake](/../../../umake) возьмём основы файлов [src/stdlibs.hpp](/../lesson01.1/src/stdlibs.hpp), [src/build.umake](/../lesson01.1/src/build.umake), [note/custom/reshu-lenovo/build.local.umake](/../lesson01.1/note/custom/reshu-lenovo/build.local.umake). Создадим симлинк `src/build.local.umake`.
```
cd src
ln -s ../note/custom/reshu-lenovo/build.local.umake
```

Далее создаём файл [src/main.cpp](/../lesson01.1/src/main.cpp) с точкой входа для нашей программы.

Собираем программу при помощи утилиты [umake](/../../../umake).
```
cd src; ../../umake/bin/umake; cd ..
```


### lesson01.2

Работу начинаем с конфигурационного файла. Чтобы не терять время на написание разбора и при этом не ограничивать будущий функционал, сделаем конфигурационный файл на языке Си++.

В файле [src/uhttpd/config.hpp](/../lesson01.2/src/uhttpd/config.hpp) разместим заголовок класса Config.

Из проекта [umake](/../../../umake) возьмём файл [src/umake/custom.hpp](/../lesson01.2/src/umake/custom.hpp).

Создадим файл [conf/uhttpd.config](/../lesson01.2/conf/uhttpd.config) с тестовой конфигурацией.

Для флагов сборки конфигурационного файла создадим файл [conf/build.umake](/../lesson01.2/conf/build.umake).

Создадим скелет класса Server в файлах
[src/server.hpp](/../lesson01.2/src/server.hpp) и
[src/server.cpp](/../lesson01.2/src/server.cpp).

В файле [src/main.cpp](/../lesson01.2/src/main.cpp), [посмотреть отличия](/../../compare/c012..c012a) добавим обработку параметра с именем конфигурационного файла и вызов класса Server.

В файле [src/stdlibs.hpp](/../lesson01.2/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c012a..c012b) поменяем io_service на io_context. Честно говоря, не представляю чем они отличаются, но поскольку в текущей документации на [boost::asio](https://www.boost.org/doc/libs/1_84_0/doc/html/boost_asio.html) упомянут только io_context, то будем использовать его.


### lesson01.3

Добавляем компиляцию и загрузку конфигурационного файла. За основу взят код загрузки настраиваемых данных из проекта [umake](/../../../umake).
