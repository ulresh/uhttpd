# 2. Журнал.

Как бы не хотелось сразу перейти к обработке запросов, но сперва надо сделать журнал. Вероятность того, что получится написать обработку запросов без ошибок с первой попытки, близка к нулю. Соответственно потребуется отладка. Гонять каждый раз gdb с пошаговым выполнением слишком трудоёмко. Намного удобнее предусмотреть в самом коде вывод текущего состояния. И лучше всего, если этот вывод будет сразу вестись в журнал, а не на стандартные потоки вывода.

### lesson02.1

В Си++ наиболее удобный способ формирования текстовых сообщений, это `std::ostream`. Только я не нашёл достаточно подходящего хранилища. Но здесь уже разговор про то, что специализированное всегда лучше универсального (только строго в рамках одной задачи). Сделаем собственное хранилище, благо делается это достаточно просто. Хранилищем будет список блоков памяти фиксированного размера (по мере заполнения добавляется новый блок) в классе `Logger::Text` (файлы
[src/logger/text.hpp](/../lesson02.1/src/logger/text.hpp)
и
[src/logger/textshp.hpp](/../lesson02.1/src/logger/textshp.hpp)
).
Для записи в это хранилище наследуем от `std::streambuf` класс `Logger::Streambuf` (файлы
[src/logger/streambuf.hpp](/../lesson02.1/src/logger/streambuf.hpp)
и
[src/logger/streambuf.cpp](/../lesson02.1/src/logger/streambuf.cpp)
).

В файле [src/stdlibs.hpp](/../lesson02.1/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c021..c021a) добавим `forward_list`.



### lesson02.2

Для работы с файлами журнала создадим класс `Logger::File`, файлы
[src/logger/file.hpp](/../lesson02.2/src/logger/file.hpp)
и
[src/logger/file.cpp](/../lesson02.2/src/logger/file.cpp).

Я собираюсь использовать этот класс для глобальных переменных, поэтому в конструкторе создаётся пустой класс только с буфером, в который сохранятся сообщения до момента открытия файла.

Функция `open` для того, чтобы открыть файл для записи. Функция `post` для отправки отформатированных сообщений на запись в файл.

Указатель `iosp` будет использоваться для передачи сообщений из всех thread'ов в тот thread, который обрабатывает запись. Сам объект, куда указывает, принадлежит другому классу, поэтому освобождение памяти здесь не требуется. До вызова `open` равен `nullptr`.

Указатель `stream` на объект, который будет вести асинхонную запись файла. До вызова `open` пустой (`nullptr`). Для освобождения памяти используем обёртку `unique_ptr`.

Флаг `busy` для признака, что запись в файл запущена, и пока она не завершится, все новые сообщения сохранять в буфере. Также флаг поднят до вызова `open`.

Флаг `disabled` для признака того, что данный файл не используется, ничего никуда писать не надо. По умолчанию не поднят.

Поля `skipped_start`, `skipped_events` и `skipped_size` будут использоваться для подсчёта сообщений, не вошедших в буфер в состоянии `busy`.

Два буфера `buffers` для записи новых сообщений в состоянии `busy`. Один буфер в процессе записи в файл, а в другой пишутся новые сообщения. Поле `current` содержит индекс буфера, используемого для записи новых сообщений.

Указатели `ptr` и `end` для обозначения области памяти, куда пишем новые сообщения. `end` указывает на конец `buffers[current]`, а `ptr` внутри `buffers[current]`.

Для формирования сообщений создадим класс `Logger::Event`, файлы
[src/logger/event.hpp](/../lesson02.2/src/logger/event.hpp)
и
[src/logger/event.cpp](/../lesson02.2/src/logger/event.cpp).
Этот класс наследуем от `std::ostream`.

В конструкторе сохраняем файл, куда будем писать, создаём объект `text`, в котором будем формировать сообщение, и проводим инициализацию для `std::ostream`.

В деструкторе производим отправку сформированного сообщения на запись.

Преобразование к типу `bool` нам пригодится для использования класса через `if();else ...`, как будет показано чуть позже, причём рабочая часть как раз в `else`, так что для работы преобразование к `bool` должно вернуть ложь.

Ссылка `file` куда будем писать, указатель `text` на хранилище сообщения, поле `buffer` для организации работы `std::ostream`.

Для записи в файл будет использоваться асинхронная запись средствами `boost::asio::stream_file`. Для его работы требуется библиотека uring. Подключим её в файлах
[src/build.umake](/../lesson02.2/src/build.umake), [посмотреть отличия](/../../compare/c022..c022a) и
[build.local.umake](/../lesson02.2/note/custom/reshu-lenovo/build.local.umake), [посмотреть отличия](/../../compare/c022a..c022b).



### lesson02.3

Каждое сообщение в журнале записывается отдельной строкой. Добавим добавление конца строки через вызов `Text::append_eol` в сформированное сообщение перед его отправкой. Вызов `Text::append_eol` содержит проверку того, что перевод строки в конце сообщения уже есть, чтобы не добавлять его дважды.

Не сложно сделать отключение этого механизма при необходимости, но у меня такой необходимости за мою практику никогда не возникало, так что делать этого не будем.

Файл [src/logger/event.cpp](/../lesson02.3/src/logger/event.cpp), [посмотреть отличия](/../../compare/c023..c023a).

Файл [src/logger/text.hpp](/../lesson02.3/src/logger/text.hpp), [посмотреть отличия](/../../compare/c023a..c023b).




### lesson02.4

В файле [src/logger/file.cpp](/../lesson02.4/src/logger/file.cpp), [посмотреть отличия](/../../compare/c024..c024a) добавим код в функции `open` и `post`.

В `open` создаём объект `stream` с привязкой к указанному файлу, записываем указатель на `io_context` того thread\`а, в котором будет выполняться весь код, вносящий какие-либо изменения в объект, и вызывается функция `ready` для перевода `*this` в состояние ожидания, либо отправки сообщений, уже успевших поступить до вызова `open`. Обращаю внимание, что `open` должен вызываться в том же thread\`е, в котором работает переданный `io_context`, а также что этот `io_context` нельзя запускать (`run`) в нескольких thread\`ах, только в одном.

В `post` мы только передаём вызов `write` в thread обработки. Таким образом `post` может быть безопасно вызван из любого thread'а. Есть нюанс с вызовом `post` раньше вызова `open`. В этом случае мы напрямую вызываем `write`. Таким образом получается, что все `open` для журналов должны быть вызваны до того, как начнут создаваться дополнительные thread\`ы.

В файле [src/logger/file.hpp](/../lesson02.4/src/logger/file.hpp), [посмотреть отличия](/../../compare/c024a..c024b) добавим заголовки функций `write` и `ready`.

Работа функции `write` зависит от того, занят ли в настоящее время объект записи (флаг `busy`). Если объект занят, то мы запишем сообщение в буфер для того, чтобы записать все накопленные сообщения в файл когда освободится объект записи. Иначе мы сразу отправляем сообщение на запись в файл и поднимаем флаг `busy`. При записи сообщения в буфер сравниваем размер сообщения и размер оставшегося в буфере места. Здесь различаем ситуации когда закончился буфер и когда новое сообщение слишком большое. Если закончился буфер, то закрываем добавление в него сообщений и начинаем считать пропущенные сообщения. А если слишком большое новое сообщение, то добавляем в буфер сообщение о большом сообщении.

Функция `ready` вызывается в конце `open` и в качестве callback\`а при записи в файл. Пожалуй это единственное место в данном проекте, где мы не передаём в callback shared_ptr на this. Это связано с тем, что мы предполагаем использование класса `Logger::File` **только** для глобальных переменных. Если потребуется другое использование, то придётся создавать новый класс.

Сейчас мы передаём в `ready` shared_ptr на сообщение и ошибку. shared_ptr на сообщение нужен обязательно, хотя в самой `ready` мы его и не используем. Дело в том, что в функцию записи мы передали только указатели, но не shared_ptr. Передавая shared_ptr на сообщение в `ready` мы защищаем указанную память от освобождения и нового использования ровно до тех пор, пока она нужна для записи. Имеем в виду, что между вызовом `async_write(*stream)` и вызовом `ready` будет вполняться другой достаточно произвольный код.

При наличии ошибки запишем сообщение об ошибке на `cerr`. Это не очень хорошо и чуть позже мы это место переделаем.

При отсутствии новых сообщений в буфере снимаем флаг `busy`. Иначе отправляем текущий буфер на запись и готовим для следующих сообщений другой буфер (напомню, что буферов у нас 2). При наличии признака пропущенных сообщений снимаем этот признак и выводим сообщение о пропущенных.

Для создания сообщений внутри функций `write` и `ready` используем новый класс DirectEvent,
файлы [src/logger/event.hpp](/../lesson02.4/src/logger/event.hpp), [посмотреть отличия](/../../compare/c024b..c024c)
и [src/logger/event.cpp](/../lesson02.4/src/logger/event.cpp), [посмотреть отличия](/../../compare/c024c..c024d). Класс DirectEvent отличается от класса Event только вызовом write вместо post и проверкой размера сообщения.

В файле [src/logger/text.hpp](/../lesson02.4/src/logger/text.hpp), [посмотреть отличия](/../../compare/c024d..c024e) добавлены функции `write_to_memory` и `reduce_to_one_buffer_with_eol`.




### lesson02.5

open + конфиги + первое сообщение

```
mkdir log
```




### lesson02.6

LOG, LOGERR



### lesson02.7

LOGTF



### lesson02.8

THRTF + try for Server::ios.run()

Продолжение в [03.md](03.md).
