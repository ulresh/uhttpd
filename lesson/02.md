# 2. Журнал.

Как бы не хотелось сразу перейти к обработке запросов, но сперва надо сделать журнал. Вероятность того, что получится написать обработку запросов без ошибок с первой попытки, близка к нулю. Соответственно потребуется отладка. Гонять каждый раз gdb с пошаговым выполнением слишком трудоёмко. Намного удобнее предусмотреть в самом коде вывод текущего состояния. И лучше всего, если этот вывод будет сразу вестись в журнал, а не на стандартные потоки вывода.

### lesson02.1

В Си++ наиболее удобный способ формирования текстовых сообщений, это `std::ostream`. Только я не нашёл достаточно подходящего хранилища. Но здесь уже разговор про то, что специализированное всегда лучше универсального (только строго в рамках одной задачи). Сделаем собственное хранилище, благо делается это достаточно просто. Хранилищем будет список блоков памяти фиксированного размера (по мере заполнения добавляется новый блок) в классе `Logger::Text` (файлы
[src/logger/text.hpp](/../lesson02.1/src/logger/text.hpp)
и
[src/logger/textshp.hpp](/../lesson02.1/src/logger/textshp.hpp)
).
Для записи в это хранилище наследуем от `std::streambuf` класс `Logger::Streambuf` (файлы
[src/logger/streambuf.hpp](/../lesson02.1/src/logger/streambuf.hpp)
и
[src/logger/streambuf.cpp](/../lesson02.1/src/logger/streambuf.cpp)
).

В файле [src/stdlibs.hpp](/../lesson02.1/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c021..c021a) добавим `forward_list`.



### lesson02.2

Для работы с файлами журнала создадим класс `Logger::File`, файлы
[src/logger/file.hpp](/../lesson02.2/src/logger/file.hpp)
и
[src/logger/file.cpp](/../lesson02.2/src/logger/file.cpp).

Я собираюсь использовать этот класс для глобальных переменных, поэтому в конструкторе создаётся пустой класс только с буфером, в который сохранятся сообщения до момента открытия файла.

Функция `open` для того, чтобы открыть файл для записи. Функция `post` для отправки отформатированных сообщений на запись в файл.

Указатель `iosp` будет использоваться для передачи сообщений из всех thread'ов в тот thread, который обрабатывает запись. Сам объект, куда указывает, принадлежит другому классу, поэтому освобождение памяти здесь не требуется. До вызова `open` равен `nullptr`.

Указатель `stream` на объект, который будет вести асинхонную запись файла. До вызова `open` пустой (`nullptr`). Для освобождения памяти используем обёртку `unique_ptr`.

Флаг `busy` для признака, что запись в файл запущена, и пока она не завершится, все новые сообщения сохранять в буфере. Также флаг поднят до вызова `open`.

Флаг `disabled` для признака того, что данный файл не используется, ничего никуда писать не надо. По умолчанию не поднят.

Поля `skipped_start`, `skipped_events` и `skipped_size` будут использоваться для подсчёта сообщений, не вошедших в буфер в состоянии `busy`.

Два буфера `buffers` для записи новых сообщений в состоянии `busy`. Один буфер в процессе записи в файл, а в другой пишутся новые сообщения. Поле `current` содержит индекс буфера, используемого для записи новых сообщений.

Указатели `ptr` и `end` для обозначения области памяти, куда пишем новые сообщения. `end` указывает на конец `buffers[current]`, а `ptr` внутри `buffers[current]`.

Для формирования сообщений создадим класс `Logger::Event`, файлы
[src/logger/event.hpp](/../lesson02.2/src/logger/event.hpp)
и
[src/logger/event.cpp](/../lesson02.2/src/logger/event.cpp).
Этот класс наследуем от `std::ostream`.

В конструкторе сохраняем файл, куда будем писать, создаём объект `text`, в котором будем формировать сообщение, и проводим инициализацию для `std::ostream`.

В деструкторе производим отправку сформированного сообщения на запись.

Преобразование к типу `bool` нам пригодится для использования класса через `if();else ...`, как будет показано чуть позже, причём рабочая часть как раз в `else`, так что для работы преобразование к `bool` должно вернуть ложь.

Ссылка `file` куда будем писать, указатель `text` на хранилище сообщения, поле `buffer` для организации работы `std::ostream`.

Для записи в файл будет использоваться асинхронная запись средствами `boost::asio::stream_file`. Для его работы требуется библиотека uring. Подключим её в файлах
[src/build.umake](/../lesson02.2/src/build.umake), [посмотреть отличия](/../../compare/c022..c022a) и
[build.local.umake](/../lesson02.2/note/custom/reshu-lenovo/build.local.umake), [посмотреть отличия](/../../compare/c022a..c022b).



### lesson02.3

Каждое сообщение в журнале записывается отдельной строкой. Добавим добавление конца строки через вызов `Text::append_eol` в сформированное сообщение перед его отправкой. Вызов `Text::append_eol` содержит проверку того, что перевод строки в конце сообщения уже есть, чтобы не добавлять его дважды.

Не сложно сделать отключение этого механизма при необходимости, но у меня такой необходимости за мою практику никогда не возникало, так что делать этого не будем.

Файл [src/logger/event.cpp](/../lesson02.3/src/logger/event.cpp), [посмотреть отличия](/../../compare/c023..c023a).

Файл [src/logger/text.hpp](/../lesson02.3/src/logger/text.hpp), [посмотреть отличия](/../../compare/c023a..c023b).




### lesson02.4

DirectEvent, File open,post,write,ready, Text::write_to_memory
Не передаём shared_ptr в обработчик, предполагая использование только в качестве глобальных переменных.



### lesson02.5

open + конфиги + первое сообщение



### lesson02.6

LOG, LOGERR



### lesson02.7

LOGTF



### lesson02.8

THRTF + try for Server::ios.run()

Продолжение в [03.md](03.md).
