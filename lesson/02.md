# 2. Журнал.

Как бы не хотелось сразу перейти к обработке запросов, но сперва надо сделать журнал. Вероятность того, что получится написать обработку запросов без ошибок с первой попытки, близка к нулю. Соответственно потребуется отладка. Гонять каждый раз gdb с пошаговым выполнением слишком трудоёмко. Намного удобнее предусмотреть в самом коде вывод текущего состояния. И лучше всего, если этот вывод будет сразу вестись в журнал, а не на стандартные потоки вывода.

### lesson02.1

В Си++ наиболее удобный способ формирования текстовых сообщений, это std::ostream. Только я не нашёл достаточно подходящего хранилища. Но здесь уже разговор про то, что специализированное всегда лучше универсального (только строго в рамках одной задачи). Сделаем собственное хранилище, благо делается это достаточно просто. Хранилищем будет список блоков памяти фиксированного размера (по мере заполнения добавляется новый блок) в классе Logger::Text (файлы
[src/logger/text.hpp](/../lesson02.1/src/logger/text.hpp)
и
[src/logger/textshp.hpp](/../lesson02.1/src/logger/textshp.hpp)
).
Для записи в это хранилище наследуем от std::streambuf класс Logger::Streambuf (файлы
[src/logger/streambuf.hpp](/../lesson02.1/src/logger/streambuf.hpp)
и
[src/logger/streambuf.cpp](/../lesson02.1/src/logger/streambuf.cpp)
).

В файле [src/stdlibs.hpp](/../lesson02.1/src/stdlibs.hpp), [посмотреть отличия](/../../compare/c021..c021a) добавим forward_list.



### lesson02.2

Скелеты для классов Logger::File и Logger::Event.



### lesson02.3

Text::append_eol



### lesson02.4

DirectEvent, File open,post,write,ready, Text::write_to_memory
Не передаём shared_ptr в обработчик, предполагая использование только в качестве глобальных переменных.



### lesson02.5

open + конфиги + первое сообщение



### lesson02.6

LOG, LOGERR



### lesson02.7

LOGTF



### lesson02.8

THRTF + try for Server::ios.run()

Продолжение в [03.md](03.md).
