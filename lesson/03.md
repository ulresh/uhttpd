# 3. hup pid term int segv backtrace

### lesson03.1

Сделаем ротацию журналов. Вернее не саму ротацию, саму ротацию проще сделать специализированными средствами (например `logrotate`), а дадим возможность ротации этими самыми специализированными утилитами. Для этого требуется по сигналу HUP переоткрыть файл журнала. Утилита ротации переименовывает существующий журнал и отправляет HUP процессу, чтобы он открыл новый файл.

Для обработки сигнала используем класс `boost::asio::signal_set`. Создадим поле `Server::sighup`. Для его инициализации добавляем в класс `Server` конструктор. Добавляем функцию обработки сигнала `sighup_handler` и функцию `close`, использовать которую мы начнём чуть позже, а пока она нужна для того, чтобы куда-то поместить вызов `sighup.cancel();`.
Файл [src/server.hpp](/../lesson03.1/src/server.hpp), [посмотреть отличия](/../../compare/c031..c031a).

В функции `Server::async_start` добавляем вызов `sighup.async_wait`.
В функции `Server::sighup_handler` (обработчик сигнала) вызываем `reopen` для всех журналов и повторяем `sighup.async_wait` для получения сигнала в следующий раз.
Файл [src/server.cpp](/../lesson03.1/src/server.cpp), [посмотреть отличия](/../../compare/c031a..c031b).

В файле [src/logger.hpp](/../lesson03.1/src/logger.hpp), [посмотреть отличия](/../../compare/c031b..c031c) создаём класс `LogErr`, который будем использовать для добавления информации об ошибках `boost` в сообщения.

В классе `Logger::File` добавляем функцию `reopen`. Собственно открытие файла вынесем в функцию `reset_stream`. Добавим поле `reopen_filepath` для хранения имени файла пока старый файл занят записью, в этом случае новый файл будет открыт в функции `ready`.
Файлы [src/logger/file.hpp](/../lesson03.1/src/logger/file.hpp), [посмотреть отличия](/../../compare/c031c..c031d)
и [src/logger/file.cpp](/../lesson03.1/src/logger/file.cpp), [посмотреть отличия](/../../compare/c031d..c031e).



### lesson03.2

Чтобы послать нашему серверу сигнал HUP нужно знать его pid. Запишем pid процесса сервера в файл.

Добавим путь к файлу с pid процесса сервера в конфиг.
Файлы [src/uhttpd/config.hpp](/../lesson03.2/src/uhttpd/config.hpp), [посмотреть отличия](/../../compare/c032..c032a)
и [conf/uhttpd.config](/../lesson03.2/conf/uhttpd.config), [посмотреть отличия](/../../compare/c032a..c032b).

Предусмотрим сразу же не только запись pid, но и удаление файла с pid после останова сервера. Для этого в заголовке класса `Server` добавляем деструктор.
Файл [src/server.hpp](/../lesson03.2/src/server.hpp), [посмотреть отличия](/../../compare/c032b..c032c).
В файле [src/server.cpp](/../lesson03.2/src/server.cpp), [посмотреть отличия](/../../compare/c032c..c032d) добавляем тело деструктора и код записи pid в файл в функции `Server::load_config`.

Файл с pid кроме прямого назначения очень удобно также использовать для того, чтобы запретить несколько запусков сервера с одинаковым конфигом. Для этого перед записью делаем блокировку файла. Я никак не могу найти возможности блокировки файла стандартными средствами `C++`, поэтому пришлось всю работу с этим файлом делать только средствами `C`.

В файле [src/logger.hpp](/../lesson03.2/src/logger.hpp), [посмотреть отличия](/../../compare/c032d..c032e) добавим класс ErrNo для вывода сообщений об ошибках errno.

Для организации хоть какого-то удобства работы с файлом средствами `C` добавим функцию write_to_file в
файлы [src/logger/text.hpp](/../lesson03.2/src/logger/text.hpp), [посмотреть отличия](/../../compare/c032e..c032f)
и [src/ss.hpp](/../lesson03.2/src/ss.hpp), [посмотреть отличия](/../../compare/c032f..c032g).




### lesson03.3




### TODO
* read timer
* sigterm
* ssl
* threads
* multieol in logs before exit
* Logger::File::ready if(error) переделать

### REMARKS

Второй запрос, пришедший до отправки ответа на первый, считаем ошибкой и закрываем соединение.

Добавить промежуточный уровень сообщений между _DEBUG и production.
